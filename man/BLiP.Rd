% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/blip.R
\name{BLiP}
\alias{BLiP}
\title{Given samples from a posterior or a list of candidate groups, BLiP performs
resolution-adaptive signal detection to maximize power while controlling
(e.g.) the FDR.}
\usage{
BLiP(
  samples = NULL,
  cand_groups = NULL,
  weight_fn = "inverse_size",
  error = "fdr",
  q = 0.1,
  max_pep = 1,
  deterministic = T,
  verbose = F,
  perturb = T,
  max_iters = 100,
  search_method = "binary",
  solver = NULL
)
}
\arguments{
\item{samples}{(N,p)-shaped matrix of posterior samples where a nonzero
value indicates the presence of a signal.}

\item{cand_groups}{A list of lists, where the inner lists must have a
"group" attribute, corresponding to the features in the group
and a "pep" attribute, corresponding to a posterior error probability.}

\item{weight_fn}{How to weight discoveries. Can be one of 'inverse_size'
or 'log_inverse_size' or a function which takes a candidate group as an input
and returns a weight.}

\item{error}{Bayesian error rate to control: one of "fwer", "pfer", "fdr", "local_fdr".}

\item{q}{The level at which to control the Bayesian FWER/PFER/FDR/local FDR.}

\item{max_pep}{Never select any group with a pep greater than max_pep.}

\item{deterministic}{Whether or not BLiP should return a deterministic solution.}

\item{verbose}{If TRUE, gives occasional progress reports.}

\item{perturb}{If TRUE, adds a tiny (random) perturbation to the weights to ensure
the existence of a unique optimal solution.}

\item{max_iters}{Maximum number of binary-search iterations for FWER when.}

\item{search_method}{For FWER control, how to find the optimal parameter for
the LP. Either 'binary' (defalt) or 'none'.}

\item{solver}{The solver to use within CVXR. By default, will use Gurobi, CBC,
or ECOS (in that order), depending on whether they are installed.}
}
\value{
A list of candidate groups, which asserts that each group contains
a signal.
}
\description{
Note: when working with image data or a continuous set
of locations, consider using BLiP_cts.
}
\examples{
# Example 1: sparse linear regression
set.seed(123); n <- 100; p <- 200
data <- blipr::generate_regression_data(n=n, p=p)
# sample from the posterior, e.g., using NPrior
nprior <- NPrior::NPrior_run(
  X=data$X, y=data$y, N=5000, prior='SpSL-G'
)
# run blip on posterior samples
detections <- blipr::BLiP(samples=t(nprior$ThetaSamples), q=0.1, error='fdr')

# Example 2: Running BLiP directly on candidate groups
cand_groups <- list(
  list(group=c(1), pep=0.1),
  list(group=c(2), pep=0.5),
  list(group=c(1,2), pep=0.01)
 )
detections <- blipr::BLiP(cand_groups=cand_groups, q=0.1, error='fdr')
}
