[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 blipr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/blipr-changepoint.html","id":"synthetic-data","dir":"Articles","previous_headings":"","what":"Synthetic data","title":"BLiP for change-point detection","text":"Given time series data \\((Y_1, \\dots, Y_n)\\), suppose interested looking “change-points”, times stochastic process changes. Often, can tell process changed, discern exactly changed observation \\(\\{Y_i\\}\\) noisy. following synthetic dataset gives one example :  detect regions true mean \\(Y\\) changed, first use bcp package fit Bayesian change-point detection model. , can apply BLiP directly top posterior samples. can plot detections check true false positives.  shown , BLiP detected change-points highlighted regions. case, turns BCP + BLiP made true discoveries.","code":"library(tidyverse) #> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── #> ✓ ggplot2 3.3.4     ✓ purrr   0.3.4 #> ✓ tibble  3.1.2     ✓ dplyr   1.0.7 #> ✓ tidyr   1.1.3     ✓ stringr 1.4.0 #> ✓ readr   1.4.0     ✓ forcats 0.5.1 #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> x dplyr::filter() masks stats::filter() #> x dplyr::lag()    masks stats::lag() library(blipr)  # Generate synthetic data set.seed(1234) n <- 200  data <- blipr::generate_changepoint_data(   n=n, sparsity=0.04, tau2=4 ) df <- data.frame(   Time=c(1:n),   Y=data$y, # observed data   beta=data$beta, # change points   mu=data$mu # mean of Y )  # Plot data ggplot(df, aes(x=Time)) +    geom_point(aes(y=Y, color='Y')) +   geom_line(aes(y=mu, color='E[Y]')) +    scale_color_manual(values=c(\"Y\"='blue', 'E[Y]'='red')) # Fit Bayesian change point model, running 10 chains of 10K samples library(bcp) #> Loading required package: grid post_samples <- matrix(nrow=0, ncol=n) N <- 2000; burnin <- N/10; chains <- 10 for (i in 1:chains) {   bcp_out <- bcp(y=data$y, return.mcmc=T, mcmc=N, burnin=burnin, p0=0.1)   post_samples <- rbind(     post_samples, t(bcp_out$mcmc.rhos[,(burnin+1):(N+burnin)])   ) } # Shift by one to ensure indexing conventions line up post_samples <- cbind(   matrix(0, dim(post_samples)[1], 1),    post_samples[,0:(n-1)] )  # Create candidate groups and apply BLiP cand_groups <- sequential_groups(samples=post_samples, max_pep=0.5) detections <- blipr::BLiP(cand_groups=cand_groups) # True change-points cps <- which(df$beta != 0) # Process detections detection_df <- data.frame(   start=sapply(detections, function(x) {min(x$group)}),   end=sapply(detections, function(x) {max(x$group)}),   true_disc=sapply(detections, function(x) {     length(intersect(x$group, cps)) > 0   } )) %>% mutate(true_disc=ifelse(true_disc, \"True\", \"False\")) # Plot ggplot(df) +    geom_point(aes(x=Time, y=Y, color='Y')) +   geom_line(aes(x=Time, y=mu, color='E[Y]')) +    geom_rect(data=detection_df, mapping=aes(       xmin=start, xmax=end + 1,       ymin=min(df$Y), ymax=max(df$Y),       fill=true_disc, alpha=1/(2*(end-start+1)),     ),   ) +   scale_color_manual(values=c(\"Y\"='blue', 'E[Y]'='red')) +    scale_fill_manual(values=c(\"True\"=\"forestgreen\", \"False\"=\"orange\")) +   labs(fill='True Discovery') +   scale_alpha(guide='none')"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Asher Spector. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Asher Spector Lucas Janson (2022). Controlled Discovery Localization Signals via Bayesian Linear Programming","code":"@Article{,   title = {Controlled Discovery and Localization of Signals via Bayesian Linear Programming},   author = {Asher Spector and Lucas Janson},   journal = {arXiv},   year = {2022}, }"},{"path":[]},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"A Bayesian Linear Program for resolution-adaptive signal detection","text":"many applications, can tell signal interest exists perfectly “localize” . example, regressing outcome Y highly correlated covariates (X1, X2), data may suggest least one (X1, X2) influences Y, may challenging tell (X1, X2) important. Likewise, genetic fine-mapping, biologists may high confidence gene influences disease without knowing precisely genetic variants cause disease. Similar problems arise many settings spatial temporal structure, including change-point detection astronomical point-source detection. Bayesian Linear Programming (BLiP) method jointly detects many signals possible localizing precisely possible. BLiP can wrap top nearly Bayesian model algorithm, return set regions contain least one signal high confidence. example, regression problems, BLiP might return region (X1, X2), suggests least one (X1, X2) important variable. BLiP controls false discovery rate also making regions narrow possible, meaning (roughly speaking) perfectly localize signals whenever possible! blipr efficient python implementation BLiP, designed BLiP can wrap top Bayesian model one two lines code.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Bayesian Linear Program for resolution-adaptive signal detection","text":"can install blipr GitHub:","code":"# install.packages(\"remotes\") remotes::install_github(\"amspector100/blipr\")"},{"path":"/index.html","id":"minimal-example","dir":"","previous_headings":"","what":"Minimal example","title":"A Bayesian Linear Program for resolution-adaptive signal detection","text":", apply BLiP perform variable selection sparse linear regression. first step generate synthetic data fit Bayesian model using, e.g., NPrior package.","code":"# Generate sparse linear regression data n <- 100; p <- 200 data <- blipr::generate_regression_data(n=n, p=p)  # Fit a Bayesian spike-and-slab model nprior <- NPrior::NPrior_run(    X=data$X, y=data$y, N=5000, prior='SpSL-G' ) post_samples <- t(nprior$ThetaSamples)  # Run BLiP on the posterior samples detections <- blipr::BLiP(   samples=post_samples, q=0.1, error='fdr' ) for (j in 1:length(detections)) {   group <- paste(detections[[j]]$group, collapse=', ')   cat(\"BLiP has detected a signal in \", group, \".\\n\", sep='') }"},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"A Bayesian Linear Program for resolution-adaptive signal detection","text":"Documentation tutorials available amspector100.github.io/blipr.","code":""},{"path":"/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"A Bayesian Linear Program for resolution-adaptive signal detection","text":"use blipr BLiP academic publication, please consider citing Spector Janson (2022). bibtex entry :","code":"@article{AS-LJ:2022,   title={Controlled Discovery and Localization of Signals via Bayesian Linear Programming},   author={Spector, Asher and Janson, Lucas},   journal={arxiv},   year={2022} }"},{"path":"/reference/BLiP.html","id":null,"dir":"Reference","previous_headings":"","what":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","title":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","text":"Given samples posterior list candidate groups, BLiP performs resolution-adaptive signal detection maximizepower controlling (e.g.) FDR.","code":""},{"path":"/reference/BLiP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","text":"","code":"BLiP(   samples = NULL,   cand_groups = NULL,   weight_fn = \"inverse_size\",   error = \"fdr\",   q = 0.1,   max_pep = 1,   deterministic = T,   verbose = F,   perturb = T,   max_iters = 100,   search_method = \"binary\",   solver = NULL )"},{"path":"/reference/BLiP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","text":"samples (N,p)-shaped matrix posterior samples nonzero value indicates presence signal. cand_groups list lists, inner lists must \"group\" attribute, corresponding features group \"pep\" attribute, corresponding posterior error probability. weight_fn weight discoveries. Can one 'inverse_size' 'log_inverse_size' function takes candidate group input returns weight. error Bayesian error rate control: one \"fwer\", \"pfer\", \"fdr\", \"local_fdr\". q level control Bayesian FWER/PFER/FDR/local FDR. max_pep Never select group pep greater max_pep. deterministic Whether BLiP return deterministic solution. verbose TRUE, gives occasional progress reports. perturb TRUE, adds tiny (random) perturbation weights ensure existence unique optimal solution. max_iters Maximum number binary-search iterations FWER . search_method FWER control, find optimal parameter LP. Either 'binary' (defalt) 'none'. solver solver use within CVXR. default, use Gurobi, CBC, ECOS (order), depending whether installed.","code":""},{"path":"/reference/BLiP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","text":"list candidate groups, asserts group contains signal.","code":""},{"path":"/reference/BLiP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given samples from a posterior or a list of candidate groups, BLiP performs\nresolution-adaptive signal detection to maximizepower while controlling\n(e.g.) the FDR. — BLiP","text":"","code":"# Example 1: sparse linear regression n <- 100; p <- 200 data <- blipr::generate_regression_data(n=n, p=p) # sample from the posterior, e.g., using NPrior nprior <- NPrior::NPrior_run(   X=data$X, y=data$y, N=5000, prior='SpSL-G' ) #> Error in NPrior::NPrior_run(X = data$X, y = data$y, N = 5000, prior = \"SpSL-G\"): object 'n' not found # run blip on posterior samples detections <- blipr::BLiP(samples=t(nprior$ThetaSamples), q=0.1, error='fdr') #> Error in t(nprior$ThetaSamples): object 'nprior' not found  # Example 2: Running BLiP directly on candidate groups cand_groups <- list(   list(group=c(1), pep=0.1),   list(group=c(2), pep=0.5),   list(group=c(1,2), pep=0.01)  ) detections <- blipr::BLiP(cand_groups=cand_groups, q=0.1, error='fdr')"},{"path":"/reference/dist_matrix_to_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates groups based on dist_matrix using hierarchical clustering — dist_matrix_to_groups","title":"Creates groups based on dist_matrix using hierarchical clustering — dist_matrix_to_groups","text":"Creates groups based dist_matrix using hierarchical clustering","code":""},{"path":"/reference/dist_matrix_to_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates groups based on dist_matrix using hierarchical clustering — dist_matrix_to_groups","text":"","code":"dist_matrix_to_groups(dist_matrix)"},{"path":"/reference/dist_matrix_to_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates groups based on dist_matrix using hierarchical clustering — dist_matrix_to_groups","text":"dist_matrix distance matrix object","code":""},{"path":"/reference/elim_redundant_features.html","id":null,"dir":"Reference","previous_headings":"","what":"After prefiltering groups, some features/locations\nmay not appear in any candidate groups. When this happens,\nthis function reindexes the locations to improve efficiency. — elim_redundant_features","title":"After prefiltering groups, some features/locations\nmay not appear in any candidate groups. When this happens,\nthis function reindexes the locations to improve efficiency. — elim_redundant_features","text":"prefiltering groups, features/locations may appear candidate groups. happens, function reindexes locations improve efficiency.","code":""},{"path":"/reference/elim_redundant_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"After prefiltering groups, some features/locations\nmay not appear in any candidate groups. When this happens,\nthis function reindexes the locations to improve efficiency. — elim_redundant_features","text":"","code":"elim_redundant_features(cand_groups)"},{"path":"/reference/generate_changepoint_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate synthetic change point data. — generate_changepoint_data","title":"Generate synthetic change point data. — generate_changepoint_data","text":"Generate synthetic change point data.","code":""},{"path":"/reference/generate_changepoint_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate synthetic change point data. — generate_changepoint_data","text":"","code":"generate_changepoint_data(n = 100, sparsity = 0.01, tau2 = 1)"},{"path":"/reference/generate_changepoint_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate synthetic change point data. — generate_changepoint_data","text":"n Number data points sparsity Proportion change points tau2 Size change points","code":""},{"path":"/reference/generate_regression_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate synthetic sparse regression data. — generate_regression_data","title":"Generate synthetic sparse regression data. — generate_regression_data","text":"Generate synthetic sparse regression data.","code":""},{"path":"/reference/generate_regression_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate synthetic sparse regression data. — generate_regression_data","text":"","code":"generate_regression_data(   n = 100,   p = 500,   a = 5,   b = 1,   sparsity = 0.05,   coeff_size = 1 )"},{"path":"/reference/generate_regression_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate synthetic sparse regression data. — generate_regression_data","text":"n Number data points p Dimensionality Correlations sampled Beta(,b) random variables. b Correlations sampled Beta(,b) random variables. sparsity Proportion nonzero coefficients. coeff_size Size coefficients","code":""},{"path":"/reference/hierarchical_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates hierarchically structured candidate groups\nbased on dist_matrix. — hierarchical_groups","title":"Creates hierarchically structured candidate groups\nbased on dist_matrix. — hierarchical_groups","text":"Creates hierarchically structured candidate groups based dist_matrix.","code":""},{"path":"/reference/hierarchical_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates hierarchically structured candidate groups\nbased on dist_matrix. — hierarchical_groups","text":"","code":"hierarchical_groups(   samples,   dist_matrix = NULL,   X = NULL,   max_pep = 1,   max_size = 25,   filter_sequential = FALSE )"},{"path":"/reference/hierarchical_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates hierarchically structured candidate groups\nbased on dist_matrix. — hierarchical_groups","text":"samples (N,p)-shaped array posterior samples nonzero value indicates presence signal. dist_matrix distance matrix corresponding distances locations, used hierarchical clustering. X design matrix regression problems, used create dist_matrix dist_matrix provided. max_pep maximum posterior error probability (PEP) allowed candidate group. Default 1. max_size maximum allowable size group. filter_sequential TRUE, ignore sequential groups variables avoid duplication.","code":""},{"path":"/reference/prefilter.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminate cand_groups with pep < max_pep — prefilter","title":"Eliminate cand_groups with pep < max_pep — prefilter","text":"Eliminate cand_groups pep < max_pep","code":""},{"path":"/reference/prefilter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminate cand_groups with pep < max_pep — prefilter","text":"","code":"prefilter(cand_groups, max_pep)"},{"path":"/reference/sequential_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates all sequential candidate groups below max_size. — sequential_groups","title":"Calculates all sequential candidate groups below max_size. — sequential_groups","text":"Calculates sequential candidate groups max_size.","code":""},{"path":"/reference/sequential_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates all sequential candidate groups below max_size. — sequential_groups","text":"","code":"sequential_groups(   samples = NULL,   susie_alphas = NULL,   q = 0,   max_pep = 1,   max_size = 25,   prenarrow = TRUE )"},{"path":"/reference/sequential_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates all sequential candidate groups below max_size. — sequential_groups","text":"samples (N,p)-shaped matrix posterior samples nonzero value indicates presence signal. susie_alphas alternative posterior samples, users may specify L x p matrix alphas SuSiE object. However, calling susie_groups recommended instead. q nominal level control error rate (optional) max_pep maximum posterior error probability (PEP) allowed candidate group. Default 1. max_size maximum allowable size group. prenarrow true, prenarrows candidate groups described paper. Defaults TRUE.","code":""},{"path":"/reference/susie_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates groups from SuSiE — susie_groups","title":"Calculates groups from SuSiE — susie_groups","text":"Calculates groups SuSiE","code":""},{"path":"/reference/susie_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates groups from SuSiE — susie_groups","text":"","code":"susie_groups(alphas, X, q, max_pep = 1, max_size = 25, prenarrow = TRUE)"},{"path":"/reference/susie_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates groups from SuSiE — susie_groups","text":"alphas L x p matrix alphas SuSiE object. X N x p design matrix. NULL, also add hierarchical groups based correlation cluster X. q nominal level control error rate max_pep maximum posterior error probability (PEP) allowed candidate group. Default 1. max_size maximum allowable size group. prenarrow true, prenarrows candidate groups described paper. Defaults TRUE.","code":""}]
